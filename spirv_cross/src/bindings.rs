/* automatically generated by rust-bindgen */

#[allow(non_snake_case, non_camel_case_types, non_upper_case_globals)]
pub mod root {
    #[allow(unused_imports)]
    use self::super::root;
    pub mod spv {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub type Id = ::std::os::raw::c_uint;
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum SourceLanguage {
            SourceLanguageUnknown = 0,
            SourceLanguageESSL = 1,
            SourceLanguageGLSL = 2,
            SourceLanguageOpenCL_C = 3,
            SourceLanguageOpenCL_CPP = 4,
            SourceLanguageHLSL = 5,
            SourceLanguageMax = 2147483647,
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum ExecutionModel {
            ExecutionModelVertex = 0,
            ExecutionModelTessellationControl = 1,
            ExecutionModelTessellationEvaluation = 2,
            ExecutionModelGeometry = 3,
            ExecutionModelFragment = 4,
            ExecutionModelGLCompute = 5,
            ExecutionModelKernel = 6,
            ExecutionModelMax = 2147483647,
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum AddressingModel {
            AddressingModelLogical = 0,
            AddressingModelPhysical32 = 1,
            AddressingModelPhysical64 = 2,
            AddressingModelMax = 2147483647,
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum MemoryModel {
            MemoryModelSimple = 0,
            MemoryModelGLSL450 = 1,
            MemoryModelOpenCL = 2,
            MemoryModelMax = 2147483647,
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum ExecutionMode {
            ExecutionModeInvocations = 0,
            ExecutionModeSpacingEqual = 1,
            ExecutionModeSpacingFractionalEven = 2,
            ExecutionModeSpacingFractionalOdd = 3,
            ExecutionModeVertexOrderCw = 4,
            ExecutionModeVertexOrderCcw = 5,
            ExecutionModePixelCenterInteger = 6,
            ExecutionModeOriginUpperLeft = 7,
            ExecutionModeOriginLowerLeft = 8,
            ExecutionModeEarlyFragmentTests = 9,
            ExecutionModePointMode = 10,
            ExecutionModeXfb = 11,
            ExecutionModeDepthReplacing = 12,
            ExecutionModeDepthGreater = 14,
            ExecutionModeDepthLess = 15,
            ExecutionModeDepthUnchanged = 16,
            ExecutionModeLocalSize = 17,
            ExecutionModeLocalSizeHint = 18,
            ExecutionModeInputPoints = 19,
            ExecutionModeInputLines = 20,
            ExecutionModeInputLinesAdjacency = 21,
            ExecutionModeTriangles = 22,
            ExecutionModeInputTrianglesAdjacency = 23,
            ExecutionModeQuads = 24,
            ExecutionModeIsolines = 25,
            ExecutionModeOutputVertices = 26,
            ExecutionModeOutputPoints = 27,
            ExecutionModeOutputLineStrip = 28,
            ExecutionModeOutputTriangleStrip = 29,
            ExecutionModeVecTypeHint = 30,
            ExecutionModeContractionOff = 31,
            ExecutionModeMax = 2147483647,
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StorageClass {
            StorageClassUniformConstant = 0,
            StorageClassInput = 1,
            StorageClassUniform = 2,
            StorageClassOutput = 3,
            StorageClassWorkgroup = 4,
            StorageClassCrossWorkgroup = 5,
            StorageClassPrivate = 6,
            StorageClassFunction = 7,
            StorageClassGeneric = 8,
            StorageClassPushConstant = 9,
            StorageClassAtomicCounter = 10,
            StorageClassImage = 11,
            StorageClassStorageBuffer = 12,
            StorageClassMax = 2147483647,
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum Dim {
            Dim1D = 0,
            Dim2D = 1,
            Dim3D = 2,
            DimCube = 3,
            DimRect = 4,
            DimBuffer = 5,
            DimSubpassData = 6,
            DimMax = 2147483647,
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum SamplerAddressingMode {
            SamplerAddressingModeNone = 0,
            SamplerAddressingModeClampToEdge = 1,
            SamplerAddressingModeClamp = 2,
            SamplerAddressingModeRepeat = 3,
            SamplerAddressingModeRepeatMirrored = 4,
            SamplerAddressingModeMax = 2147483647,
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum SamplerFilterMode {
            SamplerFilterModeNearest = 0,
            SamplerFilterModeLinear = 1,
            SamplerFilterModeMax = 2147483647,
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum ImageFormat {
            ImageFormatUnknown = 0,
            ImageFormatRgba32f = 1,
            ImageFormatRgba16f = 2,
            ImageFormatR32f = 3,
            ImageFormatRgba8 = 4,
            ImageFormatRgba8Snorm = 5,
            ImageFormatRg32f = 6,
            ImageFormatRg16f = 7,
            ImageFormatR11fG11fB10f = 8,
            ImageFormatR16f = 9,
            ImageFormatRgba16 = 10,
            ImageFormatRgb10A2 = 11,
            ImageFormatRg16 = 12,
            ImageFormatRg8 = 13,
            ImageFormatR16 = 14,
            ImageFormatR8 = 15,
            ImageFormatRgba16Snorm = 16,
            ImageFormatRg16Snorm = 17,
            ImageFormatRg8Snorm = 18,
            ImageFormatR16Snorm = 19,
            ImageFormatR8Snorm = 20,
            ImageFormatRgba32i = 21,
            ImageFormatRgba16i = 22,
            ImageFormatRgba8i = 23,
            ImageFormatR32i = 24,
            ImageFormatRg32i = 25,
            ImageFormatRg16i = 26,
            ImageFormatRg8i = 27,
            ImageFormatR16i = 28,
            ImageFormatR8i = 29,
            ImageFormatRgba32ui = 30,
            ImageFormatRgba16ui = 31,
            ImageFormatRgba8ui = 32,
            ImageFormatR32ui = 33,
            ImageFormatRgb10a2ui = 34,
            ImageFormatRg32ui = 35,
            ImageFormatRg16ui = 36,
            ImageFormatRg8ui = 37,
            ImageFormatR16ui = 38,
            ImageFormatR8ui = 39,
            ImageFormatMax = 2147483647,
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum ImageChannelOrder {
            ImageChannelOrderR = 0,
            ImageChannelOrderA = 1,
            ImageChannelOrderRG = 2,
            ImageChannelOrderRA = 3,
            ImageChannelOrderRGB = 4,
            ImageChannelOrderRGBA = 5,
            ImageChannelOrderBGRA = 6,
            ImageChannelOrderARGB = 7,
            ImageChannelOrderIntensity = 8,
            ImageChannelOrderLuminance = 9,
            ImageChannelOrderRx = 10,
            ImageChannelOrderRGx = 11,
            ImageChannelOrderRGBx = 12,
            ImageChannelOrderDepth = 13,
            ImageChannelOrderDepthStencil = 14,
            ImageChannelOrdersRGB = 15,
            ImageChannelOrdersRGBx = 16,
            ImageChannelOrdersRGBA = 17,
            ImageChannelOrdersBGRA = 18,
            ImageChannelOrderABGR = 19,
            ImageChannelOrderMax = 2147483647,
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum ImageChannelDataType {
            ImageChannelDataTypeSnormInt8 = 0,
            ImageChannelDataTypeSnormInt16 = 1,
            ImageChannelDataTypeUnormInt8 = 2,
            ImageChannelDataTypeUnormInt16 = 3,
            ImageChannelDataTypeUnormShort565 = 4,
            ImageChannelDataTypeUnormShort555 = 5,
            ImageChannelDataTypeUnormInt101010 = 6,
            ImageChannelDataTypeSignedInt8 = 7,
            ImageChannelDataTypeSignedInt16 = 8,
            ImageChannelDataTypeSignedInt32 = 9,
            ImageChannelDataTypeUnsignedInt8 = 10,
            ImageChannelDataTypeUnsignedInt16 = 11,
            ImageChannelDataTypeUnsignedInt32 = 12,
            ImageChannelDataTypeHalfFloat = 13,
            ImageChannelDataTypeFloat = 14,
            ImageChannelDataTypeUnormInt24 = 15,
            ImageChannelDataTypeUnormInt101010_2 = 16,
            ImageChannelDataTypeMax = 2147483647,
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum ImageOperandsShift {
            ImageOperandsBiasShift = 0,
            ImageOperandsLodShift = 1,
            ImageOperandsGradShift = 2,
            ImageOperandsConstOffsetShift = 3,
            ImageOperandsOffsetShift = 4,
            ImageOperandsConstOffsetsShift = 5,
            ImageOperandsSampleShift = 6,
            ImageOperandsMinLodShift = 7,
            ImageOperandsMax = 2147483647,
        }
        pub const ImageOperandsMask_ImageOperandsMaskNone:
                  root::spv::ImageOperandsMask =
            ImageOperandsMask(0);
        pub const ImageOperandsMask_ImageOperandsBiasMask:
                  root::spv::ImageOperandsMask =
            ImageOperandsMask(1);
        pub const ImageOperandsMask_ImageOperandsLodMask:
                  root::spv::ImageOperandsMask =
            ImageOperandsMask(2);
        pub const ImageOperandsMask_ImageOperandsGradMask:
                  root::spv::ImageOperandsMask =
            ImageOperandsMask(4);
        pub const ImageOperandsMask_ImageOperandsConstOffsetMask:
                  root::spv::ImageOperandsMask =
            ImageOperandsMask(8);
        pub const ImageOperandsMask_ImageOperandsOffsetMask:
                  root::spv::ImageOperandsMask =
            ImageOperandsMask(16);
        pub const ImageOperandsMask_ImageOperandsConstOffsetsMask:
                  root::spv::ImageOperandsMask =
            ImageOperandsMask(32);
        pub const ImageOperandsMask_ImageOperandsSampleMask:
                  root::spv::ImageOperandsMask =
            ImageOperandsMask(64);
        pub const ImageOperandsMask_ImageOperandsMinLodMask:
                  root::spv::ImageOperandsMask =
            ImageOperandsMask(128);
        impl ::std::ops::BitOr<root::spv::ImageOperandsMask> for
         root::spv::ImageOperandsMask {
            type
            Output
            =
            Self;
            #[inline]
            fn bitor(self, other: Self) -> Self {
                ImageOperandsMask(self.0 | other.0)
            }
        }
        impl ::std::ops::BitOrAssign for root::spv::ImageOperandsMask {
            #[inline]
            fn bitor_assign(&mut self, rhs: root::spv::ImageOperandsMask) {
                self.0 |= rhs.0;
            }
        }
        impl ::std::ops::BitAnd<root::spv::ImageOperandsMask> for
         root::spv::ImageOperandsMask {
            type
            Output
            =
            Self;
            #[inline]
            fn bitand(self, other: Self) -> Self {
                ImageOperandsMask(self.0 & other.0)
            }
        }
        impl ::std::ops::BitAndAssign for root::spv::ImageOperandsMask {
            #[inline]
            fn bitand_assign(&mut self, rhs: root::spv::ImageOperandsMask) {
                self.0 &= rhs.0;
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub struct ImageOperandsMask(pub ::std::os::raw::c_int);
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum FPFastMathModeShift {
            FPFastMathModeNotNaNShift = 0,
            FPFastMathModeNotInfShift = 1,
            FPFastMathModeNSZShift = 2,
            FPFastMathModeAllowRecipShift = 3,
            FPFastMathModeFastShift = 4,
            FPFastMathModeMax = 2147483647,
        }
        pub const FPFastMathModeMask_FPFastMathModeMaskNone:
                  root::spv::FPFastMathModeMask =
            FPFastMathModeMask(0);
        pub const FPFastMathModeMask_FPFastMathModeNotNaNMask:
                  root::spv::FPFastMathModeMask =
            FPFastMathModeMask(1);
        pub const FPFastMathModeMask_FPFastMathModeNotInfMask:
                  root::spv::FPFastMathModeMask =
            FPFastMathModeMask(2);
        pub const FPFastMathModeMask_FPFastMathModeNSZMask:
                  root::spv::FPFastMathModeMask =
            FPFastMathModeMask(4);
        pub const FPFastMathModeMask_FPFastMathModeAllowRecipMask:
                  root::spv::FPFastMathModeMask =
            FPFastMathModeMask(8);
        pub const FPFastMathModeMask_FPFastMathModeFastMask:
                  root::spv::FPFastMathModeMask =
            FPFastMathModeMask(16);
        impl ::std::ops::BitOr<root::spv::FPFastMathModeMask> for
         root::spv::FPFastMathModeMask {
            type
            Output
            =
            Self;
            #[inline]
            fn bitor(self, other: Self) -> Self {
                FPFastMathModeMask(self.0 | other.0)
            }
        }
        impl ::std::ops::BitOrAssign for root::spv::FPFastMathModeMask {
            #[inline]
            fn bitor_assign(&mut self, rhs: root::spv::FPFastMathModeMask) {
                self.0 |= rhs.0;
            }
        }
        impl ::std::ops::BitAnd<root::spv::FPFastMathModeMask> for
         root::spv::FPFastMathModeMask {
            type
            Output
            =
            Self;
            #[inline]
            fn bitand(self, other: Self) -> Self {
                FPFastMathModeMask(self.0 & other.0)
            }
        }
        impl ::std::ops::BitAndAssign for root::spv::FPFastMathModeMask {
            #[inline]
            fn bitand_assign(&mut self, rhs: root::spv::FPFastMathModeMask) {
                self.0 &= rhs.0;
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub struct FPFastMathModeMask(pub ::std::os::raw::c_int);
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum FPRoundingMode {
            FPRoundingModeRTE = 0,
            FPRoundingModeRTZ = 1,
            FPRoundingModeRTP = 2,
            FPRoundingModeRTN = 3,
            FPRoundingModeMax = 2147483647,
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum LinkageType {
            LinkageTypeExport = 0,
            LinkageTypeImport = 1,
            LinkageTypeMax = 2147483647,
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum AccessQualifier {
            AccessQualifierReadOnly = 0,
            AccessQualifierWriteOnly = 1,
            AccessQualifierReadWrite = 2,
            AccessQualifierMax = 2147483647,
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum FunctionParameterAttribute {
            FunctionParameterAttributeZext = 0,
            FunctionParameterAttributeSext = 1,
            FunctionParameterAttributeByVal = 2,
            FunctionParameterAttributeSret = 3,
            FunctionParameterAttributeNoAlias = 4,
            FunctionParameterAttributeNoCapture = 5,
            FunctionParameterAttributeNoWrite = 6,
            FunctionParameterAttributeNoReadWrite = 7,
            FunctionParameterAttributeMax = 2147483647,
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum Decoration {
            DecorationRelaxedPrecision = 0,
            DecorationSpecId = 1,
            DecorationBlock = 2,
            DecorationBufferBlock = 3,
            DecorationRowMajor = 4,
            DecorationColMajor = 5,
            DecorationArrayStride = 6,
            DecorationMatrixStride = 7,
            DecorationGLSLShared = 8,
            DecorationGLSLPacked = 9,
            DecorationCPacked = 10,
            DecorationBuiltIn = 11,
            DecorationNoPerspective = 13,
            DecorationFlat = 14,
            DecorationPatch = 15,
            DecorationCentroid = 16,
            DecorationSample = 17,
            DecorationInvariant = 18,
            DecorationRestrict = 19,
            DecorationAliased = 20,
            DecorationVolatile = 21,
            DecorationConstant = 22,
            DecorationCoherent = 23,
            DecorationNonWritable = 24,
            DecorationNonReadable = 25,
            DecorationUniform = 26,
            DecorationSaturatedConversion = 28,
            DecorationStream = 29,
            DecorationLocation = 30,
            DecorationComponent = 31,
            DecorationIndex = 32,
            DecorationBinding = 33,
            DecorationDescriptorSet = 34,
            DecorationOffset = 35,
            DecorationXfbBuffer = 36,
            DecorationXfbStride = 37,
            DecorationFuncParamAttr = 38,
            DecorationFPRoundingMode = 39,
            DecorationFPFastMathMode = 40,
            DecorationLinkageAttributes = 41,
            DecorationNoContraction = 42,
            DecorationInputAttachmentIndex = 43,
            DecorationAlignment = 44,
            DecorationOverrideCoverageNV = 5248,
            DecorationPassthroughNV = 5250,
            DecorationViewportRelativeNV = 5252,
            DecorationSecondaryViewportRelativeNV = 5256,
            DecorationMax = 2147483647,
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum BuiltIn {
            BuiltInPosition = 0,
            BuiltInPointSize = 1,
            BuiltInClipDistance = 3,
            BuiltInCullDistance = 4,
            BuiltInVertexId = 5,
            BuiltInInstanceId = 6,
            BuiltInPrimitiveId = 7,
            BuiltInInvocationId = 8,
            BuiltInLayer = 9,
            BuiltInViewportIndex = 10,
            BuiltInTessLevelOuter = 11,
            BuiltInTessLevelInner = 12,
            BuiltInTessCoord = 13,
            BuiltInPatchVertices = 14,
            BuiltInFragCoord = 15,
            BuiltInPointCoord = 16,
            BuiltInFrontFacing = 17,
            BuiltInSampleId = 18,
            BuiltInSamplePosition = 19,
            BuiltInSampleMask = 20,
            BuiltInFragDepth = 22,
            BuiltInHelperInvocation = 23,
            BuiltInNumWorkgroups = 24,
            BuiltInWorkgroupSize = 25,
            BuiltInWorkgroupId = 26,
            BuiltInLocalInvocationId = 27,
            BuiltInGlobalInvocationId = 28,
            BuiltInLocalInvocationIndex = 29,
            BuiltInWorkDim = 30,
            BuiltInGlobalSize = 31,
            BuiltInEnqueuedWorkgroupSize = 32,
            BuiltInGlobalOffset = 33,
            BuiltInGlobalLinearId = 34,
            BuiltInSubgroupSize = 36,
            BuiltInSubgroupMaxSize = 37,
            BuiltInNumSubgroups = 38,
            BuiltInNumEnqueuedSubgroups = 39,
            BuiltInSubgroupId = 40,
            BuiltInSubgroupLocalInvocationId = 41,
            BuiltInVertexIndex = 42,
            BuiltInInstanceIndex = 43,
            BuiltInSubgroupEqMaskKHR = 4416,
            BuiltInSubgroupGeMaskKHR = 4417,
            BuiltInSubgroupGtMaskKHR = 4418,
            BuiltInSubgroupLeMaskKHR = 4419,
            BuiltInSubgroupLtMaskKHR = 4420,
            BuiltInBaseVertex = 4424,
            BuiltInBaseInstance = 4425,
            BuiltInDrawIndex = 4426,
            BuiltInDeviceIndex = 4438,
            BuiltInViewIndex = 4440,
            BuiltInViewportMaskNV = 5253,
            BuiltInSecondaryPositionNV = 5257,
            BuiltInSecondaryViewportMaskNV = 5258,
            BuiltInPositionPerViewNV = 5261,
            BuiltInViewportMaskPerViewNV = 5262,
            BuiltInMax = 2147483647,
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum SelectionControlShift {
            SelectionControlFlattenShift = 0,
            SelectionControlDontFlattenShift = 1,
            SelectionControlMax = 2147483647,
        }
        pub const SelectionControlMask_SelectionControlMaskNone:
                  root::spv::SelectionControlMask =
            SelectionControlMask(0);
        pub const SelectionControlMask_SelectionControlFlattenMask:
                  root::spv::SelectionControlMask =
            SelectionControlMask(1);
        pub const SelectionControlMask_SelectionControlDontFlattenMask:
                  root::spv::SelectionControlMask =
            SelectionControlMask(2);
        impl ::std::ops::BitOr<root::spv::SelectionControlMask> for
         root::spv::SelectionControlMask {
            type
            Output
            =
            Self;
            #[inline]
            fn bitor(self, other: Self) -> Self {
                SelectionControlMask(self.0 | other.0)
            }
        }
        impl ::std::ops::BitOrAssign for root::spv::SelectionControlMask {
            #[inline]
            fn bitor_assign(&mut self, rhs: root::spv::SelectionControlMask) {
                self.0 |= rhs.0;
            }
        }
        impl ::std::ops::BitAnd<root::spv::SelectionControlMask> for
         root::spv::SelectionControlMask {
            type
            Output
            =
            Self;
            #[inline]
            fn bitand(self, other: Self) -> Self {
                SelectionControlMask(self.0 & other.0)
            }
        }
        impl ::std::ops::BitAndAssign for root::spv::SelectionControlMask {
            #[inline]
            fn bitand_assign(&mut self,
                             rhs: root::spv::SelectionControlMask) {
                self.0 &= rhs.0;
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub struct SelectionControlMask(pub ::std::os::raw::c_int);
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum LoopControlShift {
            LoopControlUnrollShift = 0,
            LoopControlDontUnrollShift = 1,
            LoopControlMax = 2147483647,
        }
        pub const LoopControlMask_LoopControlMaskNone:
                  root::spv::LoopControlMask =
            LoopControlMask(0);
        pub const LoopControlMask_LoopControlUnrollMask:
                  root::spv::LoopControlMask =
            LoopControlMask(1);
        pub const LoopControlMask_LoopControlDontUnrollMask:
                  root::spv::LoopControlMask =
            LoopControlMask(2);
        impl ::std::ops::BitOr<root::spv::LoopControlMask> for
         root::spv::LoopControlMask {
            type
            Output
            =
            Self;
            #[inline]
            fn bitor(self, other: Self) -> Self {
                LoopControlMask(self.0 | other.0)
            }
        }
        impl ::std::ops::BitOrAssign for root::spv::LoopControlMask {
            #[inline]
            fn bitor_assign(&mut self, rhs: root::spv::LoopControlMask) {
                self.0 |= rhs.0;
            }
        }
        impl ::std::ops::BitAnd<root::spv::LoopControlMask> for
         root::spv::LoopControlMask {
            type
            Output
            =
            Self;
            #[inline]
            fn bitand(self, other: Self) -> Self {
                LoopControlMask(self.0 & other.0)
            }
        }
        impl ::std::ops::BitAndAssign for root::spv::LoopControlMask {
            #[inline]
            fn bitand_assign(&mut self, rhs: root::spv::LoopControlMask) {
                self.0 &= rhs.0;
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub struct LoopControlMask(pub ::std::os::raw::c_int);
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum FunctionControlShift {
            FunctionControlInlineShift = 0,
            FunctionControlDontInlineShift = 1,
            FunctionControlPureShift = 2,
            FunctionControlConstShift = 3,
            FunctionControlMax = 2147483647,
        }
        pub const FunctionControlMask_FunctionControlMaskNone:
                  root::spv::FunctionControlMask =
            FunctionControlMask(0);
        pub const FunctionControlMask_FunctionControlInlineMask:
                  root::spv::FunctionControlMask =
            FunctionControlMask(1);
        pub const FunctionControlMask_FunctionControlDontInlineMask:
                  root::spv::FunctionControlMask =
            FunctionControlMask(2);
        pub const FunctionControlMask_FunctionControlPureMask:
                  root::spv::FunctionControlMask =
            FunctionControlMask(4);
        pub const FunctionControlMask_FunctionControlConstMask:
                  root::spv::FunctionControlMask =
            FunctionControlMask(8);
        impl ::std::ops::BitOr<root::spv::FunctionControlMask> for
         root::spv::FunctionControlMask {
            type
            Output
            =
            Self;
            #[inline]
            fn bitor(self, other: Self) -> Self {
                FunctionControlMask(self.0 | other.0)
            }
        }
        impl ::std::ops::BitOrAssign for root::spv::FunctionControlMask {
            #[inline]
            fn bitor_assign(&mut self, rhs: root::spv::FunctionControlMask) {
                self.0 |= rhs.0;
            }
        }
        impl ::std::ops::BitAnd<root::spv::FunctionControlMask> for
         root::spv::FunctionControlMask {
            type
            Output
            =
            Self;
            #[inline]
            fn bitand(self, other: Self) -> Self {
                FunctionControlMask(self.0 & other.0)
            }
        }
        impl ::std::ops::BitAndAssign for root::spv::FunctionControlMask {
            #[inline]
            fn bitand_assign(&mut self, rhs: root::spv::FunctionControlMask) {
                self.0 &= rhs.0;
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub struct FunctionControlMask(pub ::std::os::raw::c_int);
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum MemorySemanticsShift {
            MemorySemanticsAcquireShift = 1,
            MemorySemanticsReleaseShift = 2,
            MemorySemanticsAcquireReleaseShift = 3,
            MemorySemanticsSequentiallyConsistentShift = 4,
            MemorySemanticsUniformMemoryShift = 6,
            MemorySemanticsSubgroupMemoryShift = 7,
            MemorySemanticsWorkgroupMemoryShift = 8,
            MemorySemanticsCrossWorkgroupMemoryShift = 9,
            MemorySemanticsAtomicCounterMemoryShift = 10,
            MemorySemanticsImageMemoryShift = 11,
            MemorySemanticsMax = 2147483647,
        }
        pub const MemorySemanticsMask_MemorySemanticsMaskNone:
                  root::spv::MemorySemanticsMask =
            MemorySemanticsMask(0);
        pub const MemorySemanticsMask_MemorySemanticsAcquireMask:
                  root::spv::MemorySemanticsMask =
            MemorySemanticsMask(2);
        pub const MemorySemanticsMask_MemorySemanticsReleaseMask:
                  root::spv::MemorySemanticsMask =
            MemorySemanticsMask(4);
        pub const MemorySemanticsMask_MemorySemanticsAcquireReleaseMask:
                  root::spv::MemorySemanticsMask =
            MemorySemanticsMask(8);
        pub const MemorySemanticsMask_MemorySemanticsSequentiallyConsistentMask:
                  root::spv::MemorySemanticsMask =
            MemorySemanticsMask(16);
        pub const MemorySemanticsMask_MemorySemanticsUniformMemoryMask:
                  root::spv::MemorySemanticsMask =
            MemorySemanticsMask(64);
        pub const MemorySemanticsMask_MemorySemanticsSubgroupMemoryMask:
                  root::spv::MemorySemanticsMask =
            MemorySemanticsMask(128);
        pub const MemorySemanticsMask_MemorySemanticsWorkgroupMemoryMask:
                  root::spv::MemorySemanticsMask =
            MemorySemanticsMask(256);
        pub const MemorySemanticsMask_MemorySemanticsCrossWorkgroupMemoryMask:
                  root::spv::MemorySemanticsMask =
            MemorySemanticsMask(512);
        pub const MemorySemanticsMask_MemorySemanticsAtomicCounterMemoryMask:
                  root::spv::MemorySemanticsMask =
            MemorySemanticsMask(1024);
        pub const MemorySemanticsMask_MemorySemanticsImageMemoryMask:
                  root::spv::MemorySemanticsMask =
            MemorySemanticsMask(2048);
        impl ::std::ops::BitOr<root::spv::MemorySemanticsMask> for
         root::spv::MemorySemanticsMask {
            type
            Output
            =
            Self;
            #[inline]
            fn bitor(self, other: Self) -> Self {
                MemorySemanticsMask(self.0 | other.0)
            }
        }
        impl ::std::ops::BitOrAssign for root::spv::MemorySemanticsMask {
            #[inline]
            fn bitor_assign(&mut self, rhs: root::spv::MemorySemanticsMask) {
                self.0 |= rhs.0;
            }
        }
        impl ::std::ops::BitAnd<root::spv::MemorySemanticsMask> for
         root::spv::MemorySemanticsMask {
            type
            Output
            =
            Self;
            #[inline]
            fn bitand(self, other: Self) -> Self {
                MemorySemanticsMask(self.0 & other.0)
            }
        }
        impl ::std::ops::BitAndAssign for root::spv::MemorySemanticsMask {
            #[inline]
            fn bitand_assign(&mut self, rhs: root::spv::MemorySemanticsMask) {
                self.0 &= rhs.0;
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub struct MemorySemanticsMask(pub ::std::os::raw::c_int);
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum MemoryAccessShift {
            MemoryAccessVolatileShift = 0,
            MemoryAccessAlignedShift = 1,
            MemoryAccessNontemporalShift = 2,
            MemoryAccessMax = 2147483647,
        }
        pub const MemoryAccessMask_MemoryAccessMaskNone:
                  root::spv::MemoryAccessMask =
            MemoryAccessMask(0);
        pub const MemoryAccessMask_MemoryAccessVolatileMask:
                  root::spv::MemoryAccessMask =
            MemoryAccessMask(1);
        pub const MemoryAccessMask_MemoryAccessAlignedMask:
                  root::spv::MemoryAccessMask =
            MemoryAccessMask(2);
        pub const MemoryAccessMask_MemoryAccessNontemporalMask:
                  root::spv::MemoryAccessMask =
            MemoryAccessMask(4);
        impl ::std::ops::BitOr<root::spv::MemoryAccessMask> for
         root::spv::MemoryAccessMask {
            type
            Output
            =
            Self;
            #[inline]
            fn bitor(self, other: Self) -> Self {
                MemoryAccessMask(self.0 | other.0)
            }
        }
        impl ::std::ops::BitOrAssign for root::spv::MemoryAccessMask {
            #[inline]
            fn bitor_assign(&mut self, rhs: root::spv::MemoryAccessMask) {
                self.0 |= rhs.0;
            }
        }
        impl ::std::ops::BitAnd<root::spv::MemoryAccessMask> for
         root::spv::MemoryAccessMask {
            type
            Output
            =
            Self;
            #[inline]
            fn bitand(self, other: Self) -> Self {
                MemoryAccessMask(self.0 & other.0)
            }
        }
        impl ::std::ops::BitAndAssign for root::spv::MemoryAccessMask {
            #[inline]
            fn bitand_assign(&mut self, rhs: root::spv::MemoryAccessMask) {
                self.0 &= rhs.0;
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub struct MemoryAccessMask(pub ::std::os::raw::c_int);
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum Scope {
            ScopeCrossDevice = 0,
            ScopeDevice = 1,
            ScopeWorkgroup = 2,
            ScopeSubgroup = 3,
            ScopeInvocation = 4,
            ScopeMax = 2147483647,
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum GroupOperation {
            GroupOperationReduce = 0,
            GroupOperationInclusiveScan = 1,
            GroupOperationExclusiveScan = 2,
            GroupOperationMax = 2147483647,
        }
        pub const KernelEnqueueFlags_KernelEnqueueFlagsNoWait:
                  root::spv::KernelEnqueueFlags =
            KernelEnqueueFlags(0);
        pub const KernelEnqueueFlags_KernelEnqueueFlagsWaitKernel:
                  root::spv::KernelEnqueueFlags =
            KernelEnqueueFlags(1);
        pub const KernelEnqueueFlags_KernelEnqueueFlagsWaitWorkGroup:
                  root::spv::KernelEnqueueFlags =
            KernelEnqueueFlags(2);
        pub const KernelEnqueueFlags_KernelEnqueueFlagsMax:
                  root::spv::KernelEnqueueFlags =
            KernelEnqueueFlags(2147483647);
        impl ::std::ops::BitOr<root::spv::KernelEnqueueFlags> for
         root::spv::KernelEnqueueFlags {
            type
            Output
            =
            Self;
            #[inline]
            fn bitor(self, other: Self) -> Self {
                KernelEnqueueFlags(self.0 | other.0)
            }
        }
        impl ::std::ops::BitOrAssign for root::spv::KernelEnqueueFlags {
            #[inline]
            fn bitor_assign(&mut self, rhs: root::spv::KernelEnqueueFlags) {
                self.0 |= rhs.0;
            }
        }
        impl ::std::ops::BitAnd<root::spv::KernelEnqueueFlags> for
         root::spv::KernelEnqueueFlags {
            type
            Output
            =
            Self;
            #[inline]
            fn bitand(self, other: Self) -> Self {
                KernelEnqueueFlags(self.0 & other.0)
            }
        }
        impl ::std::ops::BitAndAssign for root::spv::KernelEnqueueFlags {
            #[inline]
            fn bitand_assign(&mut self, rhs: root::spv::KernelEnqueueFlags) {
                self.0 &= rhs.0;
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub struct KernelEnqueueFlags(pub ::std::os::raw::c_int);
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum KernelProfilingInfoShift {
            KernelProfilingInfoCmdExecTimeShift = 0,
            KernelProfilingInfoMax = 2147483647,
        }
        pub const KernelProfilingInfoMask_KernelProfilingInfoMaskNone:
                  root::spv::KernelProfilingInfoMask =
            KernelProfilingInfoMask(0);
        pub const KernelProfilingInfoMask_KernelProfilingInfoCmdExecTimeMask:
                  root::spv::KernelProfilingInfoMask =
            KernelProfilingInfoMask(1);
        impl ::std::ops::BitOr<root::spv::KernelProfilingInfoMask> for
         root::spv::KernelProfilingInfoMask {
            type
            Output
            =
            Self;
            #[inline]
            fn bitor(self, other: Self) -> Self {
                KernelProfilingInfoMask(self.0 | other.0)
            }
        }
        impl ::std::ops::BitOrAssign for root::spv::KernelProfilingInfoMask {
            #[inline]
            fn bitor_assign(&mut self,
                            rhs: root::spv::KernelProfilingInfoMask) {
                self.0 |= rhs.0;
            }
        }
        impl ::std::ops::BitAnd<root::spv::KernelProfilingInfoMask> for
         root::spv::KernelProfilingInfoMask {
            type
            Output
            =
            Self;
            #[inline]
            fn bitand(self, other: Self) -> Self {
                KernelProfilingInfoMask(self.0 & other.0)
            }
        }
        impl ::std::ops::BitAndAssign for root::spv::KernelProfilingInfoMask {
            #[inline]
            fn bitand_assign(&mut self,
                             rhs: root::spv::KernelProfilingInfoMask) {
                self.0 &= rhs.0;
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub struct KernelProfilingInfoMask(pub ::std::os::raw::c_int);
        pub const Capability_CapabilityStorageUniformBufferBlock16:
                  root::spv::Capability =
            Capability::CapabilityStorageBuffer16BitAccess;
        pub const Capability_CapabilityUniformAndStorageBuffer16BitAccess:
                  root::spv::Capability =
            Capability::CapabilityStorageUniform16;
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum Capability {
            CapabilityMatrix = 0,
            CapabilityShader = 1,
            CapabilityGeometry = 2,
            CapabilityTessellation = 3,
            CapabilityAddresses = 4,
            CapabilityLinkage = 5,
            CapabilityKernel = 6,
            CapabilityVector16 = 7,
            CapabilityFloat16Buffer = 8,
            CapabilityFloat16 = 9,
            CapabilityFloat64 = 10,
            CapabilityInt64 = 11,
            CapabilityInt64Atomics = 12,
            CapabilityImageBasic = 13,
            CapabilityImageReadWrite = 14,
            CapabilityImageMipmap = 15,
            CapabilityPipes = 17,
            CapabilityGroups = 18,
            CapabilityDeviceEnqueue = 19,
            CapabilityLiteralSampler = 20,
            CapabilityAtomicStorage = 21,
            CapabilityInt16 = 22,
            CapabilityTessellationPointSize = 23,
            CapabilityGeometryPointSize = 24,
            CapabilityImageGatherExtended = 25,
            CapabilityStorageImageMultisample = 27,
            CapabilityUniformBufferArrayDynamicIndexing = 28,
            CapabilitySampledImageArrayDynamicIndexing = 29,
            CapabilityStorageBufferArrayDynamicIndexing = 30,
            CapabilityStorageImageArrayDynamicIndexing = 31,
            CapabilityClipDistance = 32,
            CapabilityCullDistance = 33,
            CapabilityImageCubeArray = 34,
            CapabilitySampleRateShading = 35,
            CapabilityImageRect = 36,
            CapabilitySampledRect = 37,
            CapabilityGenericPointer = 38,
            CapabilityInt8 = 39,
            CapabilityInputAttachment = 40,
            CapabilitySparseResidency = 41,
            CapabilityMinLod = 42,
            CapabilitySampled1D = 43,
            CapabilityImage1D = 44,
            CapabilitySampledCubeArray = 45,
            CapabilitySampledBuffer = 46,
            CapabilityImageBuffer = 47,
            CapabilityImageMSArray = 48,
            CapabilityStorageImageExtendedFormats = 49,
            CapabilityImageQuery = 50,
            CapabilityDerivativeControl = 51,
            CapabilityInterpolationFunction = 52,
            CapabilityTransformFeedback = 53,
            CapabilityGeometryStreams = 54,
            CapabilityStorageImageReadWithoutFormat = 55,
            CapabilityStorageImageWriteWithoutFormat = 56,
            CapabilityMultiViewport = 57,
            CapabilitySubgroupBallotKHR = 4423,
            CapabilityDrawParameters = 4427,
            CapabilitySubgroupVoteKHR = 4431,
            CapabilityStorageBuffer16BitAccess = 4433,
            CapabilityStorageUniform16 = 4434,
            CapabilityStoragePushConstant16 = 4435,
            CapabilityStorageInputOutput16 = 4436,
            CapabilityDeviceGroup = 4437,
            CapabilityMultiView = 4439,
            CapabilityVariablePointersStorageBuffer = 4441,
            CapabilityVariablePointers = 4442,
            CapabilitySampleMaskOverrideCoverageNV = 5249,
            CapabilityGeometryShaderPassthroughNV = 5251,
            CapabilityShaderViewportIndexLayerNV = 5254,
            CapabilityShaderViewportMaskNV = 5255,
            CapabilityShaderStereoViewNV = 5259,
            CapabilityPerViewAttributesNV = 5260,
            CapabilityMax = 2147483647,
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum Op {
            OpNop = 0,
            OpUndef = 1,
            OpSourceContinued = 2,
            OpSource = 3,
            OpSourceExtension = 4,
            OpName = 5,
            OpMemberName = 6,
            OpString = 7,
            OpLine = 8,
            OpExtension = 10,
            OpExtInstImport = 11,
            OpExtInst = 12,
            OpMemoryModel = 14,
            OpEntryPoint = 15,
            OpExecutionMode = 16,
            OpCapability = 17,
            OpTypeVoid = 19,
            OpTypeBool = 20,
            OpTypeInt = 21,
            OpTypeFloat = 22,
            OpTypeVector = 23,
            OpTypeMatrix = 24,
            OpTypeImage = 25,
            OpTypeSampler = 26,
            OpTypeSampledImage = 27,
            OpTypeArray = 28,
            OpTypeRuntimeArray = 29,
            OpTypeStruct = 30,
            OpTypeOpaque = 31,
            OpTypePointer = 32,
            OpTypeFunction = 33,
            OpTypeEvent = 34,
            OpTypeDeviceEvent = 35,
            OpTypeReserveId = 36,
            OpTypeQueue = 37,
            OpTypePipe = 38,
            OpTypeForwardPointer = 39,
            OpConstantTrue = 41,
            OpConstantFalse = 42,
            OpConstant = 43,
            OpConstantComposite = 44,
            OpConstantSampler = 45,
            OpConstantNull = 46,
            OpSpecConstantTrue = 48,
            OpSpecConstantFalse = 49,
            OpSpecConstant = 50,
            OpSpecConstantComposite = 51,
            OpSpecConstantOp = 52,
            OpFunction = 54,
            OpFunctionParameter = 55,
            OpFunctionEnd = 56,
            OpFunctionCall = 57,
            OpVariable = 59,
            OpImageTexelPointer = 60,
            OpLoad = 61,
            OpStore = 62,
            OpCopyMemory = 63,
            OpCopyMemorySized = 64,
            OpAccessChain = 65,
            OpInBoundsAccessChain = 66,
            OpPtrAccessChain = 67,
            OpArrayLength = 68,
            OpGenericPtrMemSemantics = 69,
            OpInBoundsPtrAccessChain = 70,
            OpDecorate = 71,
            OpMemberDecorate = 72,
            OpDecorationGroup = 73,
            OpGroupDecorate = 74,
            OpGroupMemberDecorate = 75,
            OpVectorExtractDynamic = 77,
            OpVectorInsertDynamic = 78,
            OpVectorShuffle = 79,
            OpCompositeConstruct = 80,
            OpCompositeExtract = 81,
            OpCompositeInsert = 82,
            OpCopyObject = 83,
            OpTranspose = 84,
            OpSampledImage = 86,
            OpImageSampleImplicitLod = 87,
            OpImageSampleExplicitLod = 88,
            OpImageSampleDrefImplicitLod = 89,
            OpImageSampleDrefExplicitLod = 90,
            OpImageSampleProjImplicitLod = 91,
            OpImageSampleProjExplicitLod = 92,
            OpImageSampleProjDrefImplicitLod = 93,
            OpImageSampleProjDrefExplicitLod = 94,
            OpImageFetch = 95,
            OpImageGather = 96,
            OpImageDrefGather = 97,
            OpImageRead = 98,
            OpImageWrite = 99,
            OpImage = 100,
            OpImageQueryFormat = 101,
            OpImageQueryOrder = 102,
            OpImageQuerySizeLod = 103,
            OpImageQuerySize = 104,
            OpImageQueryLod = 105,
            OpImageQueryLevels = 106,
            OpImageQuerySamples = 107,
            OpConvertFToU = 109,
            OpConvertFToS = 110,
            OpConvertSToF = 111,
            OpConvertUToF = 112,
            OpUConvert = 113,
            OpSConvert = 114,
            OpFConvert = 115,
            OpQuantizeToF16 = 116,
            OpConvertPtrToU = 117,
            OpSatConvertSToU = 118,
            OpSatConvertUToS = 119,
            OpConvertUToPtr = 120,
            OpPtrCastToGeneric = 121,
            OpGenericCastToPtr = 122,
            OpGenericCastToPtrExplicit = 123,
            OpBitcast = 124,
            OpSNegate = 126,
            OpFNegate = 127,
            OpIAdd = 128,
            OpFAdd = 129,
            OpISub = 130,
            OpFSub = 131,
            OpIMul = 132,
            OpFMul = 133,
            OpUDiv = 134,
            OpSDiv = 135,
            OpFDiv = 136,
            OpUMod = 137,
            OpSRem = 138,
            OpSMod = 139,
            OpFRem = 140,
            OpFMod = 141,
            OpVectorTimesScalar = 142,
            OpMatrixTimesScalar = 143,
            OpVectorTimesMatrix = 144,
            OpMatrixTimesVector = 145,
            OpMatrixTimesMatrix = 146,
            OpOuterProduct = 147,
            OpDot = 148,
            OpIAddCarry = 149,
            OpISubBorrow = 150,
            OpUMulExtended = 151,
            OpSMulExtended = 152,
            OpAny = 154,
            OpAll = 155,
            OpIsNan = 156,
            OpIsInf = 157,
            OpIsFinite = 158,
            OpIsNormal = 159,
            OpSignBitSet = 160,
            OpLessOrGreater = 161,
            OpOrdered = 162,
            OpUnordered = 163,
            OpLogicalEqual = 164,
            OpLogicalNotEqual = 165,
            OpLogicalOr = 166,
            OpLogicalAnd = 167,
            OpLogicalNot = 168,
            OpSelect = 169,
            OpIEqual = 170,
            OpINotEqual = 171,
            OpUGreaterThan = 172,
            OpSGreaterThan = 173,
            OpUGreaterThanEqual = 174,
            OpSGreaterThanEqual = 175,
            OpULessThan = 176,
            OpSLessThan = 177,
            OpULessThanEqual = 178,
            OpSLessThanEqual = 179,
            OpFOrdEqual = 180,
            OpFUnordEqual = 181,
            OpFOrdNotEqual = 182,
            OpFUnordNotEqual = 183,
            OpFOrdLessThan = 184,
            OpFUnordLessThan = 185,
            OpFOrdGreaterThan = 186,
            OpFUnordGreaterThan = 187,
            OpFOrdLessThanEqual = 188,
            OpFUnordLessThanEqual = 189,
            OpFOrdGreaterThanEqual = 190,
            OpFUnordGreaterThanEqual = 191,
            OpShiftRightLogical = 194,
            OpShiftRightArithmetic = 195,
            OpShiftLeftLogical = 196,
            OpBitwiseOr = 197,
            OpBitwiseXor = 198,
            OpBitwiseAnd = 199,
            OpNot = 200,
            OpBitFieldInsert = 201,
            OpBitFieldSExtract = 202,
            OpBitFieldUExtract = 203,
            OpBitReverse = 204,
            OpBitCount = 205,
            OpDPdx = 207,
            OpDPdy = 208,
            OpFwidth = 209,
            OpDPdxFine = 210,
            OpDPdyFine = 211,
            OpFwidthFine = 212,
            OpDPdxCoarse = 213,
            OpDPdyCoarse = 214,
            OpFwidthCoarse = 215,
            OpEmitVertex = 218,
            OpEndPrimitive = 219,
            OpEmitStreamVertex = 220,
            OpEndStreamPrimitive = 221,
            OpControlBarrier = 224,
            OpMemoryBarrier = 225,
            OpAtomicLoad = 227,
            OpAtomicStore = 228,
            OpAtomicExchange = 229,
            OpAtomicCompareExchange = 230,
            OpAtomicCompareExchangeWeak = 231,
            OpAtomicIIncrement = 232,
            OpAtomicIDecrement = 233,
            OpAtomicIAdd = 234,
            OpAtomicISub = 235,
            OpAtomicSMin = 236,
            OpAtomicUMin = 237,
            OpAtomicSMax = 238,
            OpAtomicUMax = 239,
            OpAtomicAnd = 240,
            OpAtomicOr = 241,
            OpAtomicXor = 242,
            OpPhi = 245,
            OpLoopMerge = 246,
            OpSelectionMerge = 247,
            OpLabel = 248,
            OpBranch = 249,
            OpBranchConditional = 250,
            OpSwitch = 251,
            OpKill = 252,
            OpReturn = 253,
            OpReturnValue = 254,
            OpUnreachable = 255,
            OpLifetimeStart = 256,
            OpLifetimeStop = 257,
            OpGroupAsyncCopy = 259,
            OpGroupWaitEvents = 260,
            OpGroupAll = 261,
            OpGroupAny = 262,
            OpGroupBroadcast = 263,
            OpGroupIAdd = 264,
            OpGroupFAdd = 265,
            OpGroupFMin = 266,
            OpGroupUMin = 267,
            OpGroupSMin = 268,
            OpGroupFMax = 269,
            OpGroupUMax = 270,
            OpGroupSMax = 271,
            OpReadPipe = 274,
            OpWritePipe = 275,
            OpReservedReadPipe = 276,
            OpReservedWritePipe = 277,
            OpReserveReadPipePackets = 278,
            OpReserveWritePipePackets = 279,
            OpCommitReadPipe = 280,
            OpCommitWritePipe = 281,
            OpIsValidReserveId = 282,
            OpGetNumPipePackets = 283,
            OpGetMaxPipePackets = 284,
            OpGroupReserveReadPipePackets = 285,
            OpGroupReserveWritePipePackets = 286,
            OpGroupCommitReadPipe = 287,
            OpGroupCommitWritePipe = 288,
            OpEnqueueMarker = 291,
            OpEnqueueKernel = 292,
            OpGetKernelNDrangeSubGroupCount = 293,
            OpGetKernelNDrangeMaxSubGroupSize = 294,
            OpGetKernelWorkGroupSize = 295,
            OpGetKernelPreferredWorkGroupSizeMultiple = 296,
            OpRetainEvent = 297,
            OpReleaseEvent = 298,
            OpCreateUserEvent = 299,
            OpIsValidEvent = 300,
            OpSetUserEventStatus = 301,
            OpCaptureEventProfilingInfo = 302,
            OpGetDefaultQueue = 303,
            OpBuildNDRange = 304,
            OpImageSparseSampleImplicitLod = 305,
            OpImageSparseSampleExplicitLod = 306,
            OpImageSparseSampleDrefImplicitLod = 307,
            OpImageSparseSampleDrefExplicitLod = 308,
            OpImageSparseSampleProjImplicitLod = 309,
            OpImageSparseSampleProjExplicitLod = 310,
            OpImageSparseSampleProjDrefImplicitLod = 311,
            OpImageSparseSampleProjDrefExplicitLod = 312,
            OpImageSparseFetch = 313,
            OpImageSparseGather = 314,
            OpImageSparseDrefGather = 315,
            OpImageSparseTexelsResident = 316,
            OpNoLine = 317,
            OpAtomicFlagTestAndSet = 318,
            OpAtomicFlagClear = 319,
            OpImageSparseRead = 320,
            OpSubgroupBallotKHR = 4421,
            OpSubgroupFirstInvocationKHR = 4422,
            OpSubgroupAllKHR = 4428,
            OpSubgroupAnyKHR = 4429,
            OpSubgroupAllEqualKHR = 4430,
            OpSubgroupReadInvocationKHR = 4432,
            OpGroupIAddNonUniformAMD = 5000,
            OpGroupFAddNonUniformAMD = 5001,
            OpGroupFMinNonUniformAMD = 5002,
            OpGroupUMinNonUniformAMD = 5003,
            OpGroupSMinNonUniformAMD = 5004,
            OpGroupFMaxNonUniformAMD = 5005,
            OpGroupUMaxNonUniformAMD = 5006,
            OpGroupSMaxNonUniformAMD = 5007,
            OpFragmentMaskFetchAMD = 5011,
            OpFragmentFetchAMD = 5012,
            OpMax = 2147483647,
        }
    }
    pub mod std {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub mod _DEPRECATE_TR1_NAMESPACE {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
        pub type string = [u64; 4usize];
    }
    pub mod spirv_cross {
        #[allow(unused_imports)]
        use self::super::super::root;
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum SPIRType_BaseType {
            Unknown = 0,
            Void = 1,
            Boolean = 2,
            Char = 3,
            Int = 4,
            UInt = 5,
            Int64 = 6,
            UInt64 = 7,
            AtomicCounter = 8,
            Float = 9,
            Double = 10,
            Struct = 11,
            Image = 12,
            SampledImage = 13,
            Sampler = 14,
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct Resource {
            pub id: u32,
            pub type_id: u32,
            pub base_type_id: u32,
            pub name: root::std::string,
        }
        #[test]
        fn bindgen_test_layout_Resource() {
            assert_eq!(::std::mem::size_of::<Resource>() , 48usize , concat !
                       ( "Size of: " , stringify ! ( Resource ) ));
            assert_eq! (::std::mem::align_of::<Resource>() , 8usize , concat !
                        ( "Alignment of " , stringify ! ( Resource ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const Resource ) ) . id as * const _ as
                        usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( Resource ) ,
                        "::" , stringify ! ( id ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const Resource ) ) . type_id as * const
                        _ as usize } , 4usize , concat ! (
                        "Alignment of field: " , stringify ! ( Resource ) ,
                        "::" , stringify ! ( type_id ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const Resource ) ) . base_type_id as *
                        const _ as usize } , 8usize , concat ! (
                        "Alignment of field: " , stringify ! ( Resource ) ,
                        "::" , stringify ! ( base_type_id ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const Resource ) ) . name as * const _
                        as usize } , 16usize , concat ! (
                        "Alignment of field: " , stringify ! ( Resource ) ,
                        "::" , stringify ! ( name ) ));
        }
        impl Clone for Resource {
            fn clone(&self) -> Self { *self }
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct MSLVertexAttr {
            pub location: u32,
            pub msl_buffer: u32,
            pub msl_offset: u32,
            pub msl_stride: u32,
            pub per_instance: bool,
            pub used_by_shader: bool,
        }
        #[test]
        fn bindgen_test_layout_MSLVertexAttr() {
            assert_eq!(::std::mem::size_of::<MSLVertexAttr>() , 20usize ,
                       concat ! ( "Size of: " , stringify ! ( MSLVertexAttr )
                       ));
            assert_eq! (::std::mem::align_of::<MSLVertexAttr>() , 4usize ,
                        concat ! (
                        "Alignment of " , stringify ! ( MSLVertexAttr ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const MSLVertexAttr ) ) . location as *
                        const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! ( MSLVertexAttr )
                        , "::" , stringify ! ( location ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const MSLVertexAttr ) ) . msl_buffer as
                        * const _ as usize } , 4usize , concat ! (
                        "Alignment of field: " , stringify ! ( MSLVertexAttr )
                        , "::" , stringify ! ( msl_buffer ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const MSLVertexAttr ) ) . msl_offset as
                        * const _ as usize } , 8usize , concat ! (
                        "Alignment of field: " , stringify ! ( MSLVertexAttr )
                        , "::" , stringify ! ( msl_offset ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const MSLVertexAttr ) ) . msl_stride as
                        * const _ as usize } , 12usize , concat ! (
                        "Alignment of field: " , stringify ! ( MSLVertexAttr )
                        , "::" , stringify ! ( msl_stride ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const MSLVertexAttr ) ) . per_instance
                        as * const _ as usize } , 16usize , concat ! (
                        "Alignment of field: " , stringify ! ( MSLVertexAttr )
                        , "::" , stringify ! ( per_instance ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const MSLVertexAttr ) ) .
                        used_by_shader as * const _ as usize } , 17usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! ( MSLVertexAttr )
                        , "::" , stringify ! ( used_by_shader ) ));
        }
        impl Clone for MSLVertexAttr {
            fn clone(&self) -> Self { *self }
        }
        #[repr(C)]
        #[derive(Debug, Copy)]
        pub struct MSLResourceBinding {
            pub stage: root::spv::ExecutionModel,
            pub desc_set: u32,
            pub binding: u32,
            pub msl_buffer: u32,
            pub msl_texture: u32,
            pub msl_sampler: u32,
            pub used_by_shader: bool,
        }
        #[test]
        fn bindgen_test_layout_MSLResourceBinding() {
            assert_eq!(::std::mem::size_of::<MSLResourceBinding>() , 28usize ,
                       concat ! (
                       "Size of: " , stringify ! ( MSLResourceBinding ) ));
            assert_eq! (::std::mem::align_of::<MSLResourceBinding>() , 4usize
                        , concat ! (
                        "Alignment of " , stringify ! ( MSLResourceBinding )
                        ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const MSLResourceBinding ) ) . stage as
                        * const _ as usize } , 0usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        MSLResourceBinding ) , "::" , stringify ! ( stage )
                        ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const MSLResourceBinding ) ) . desc_set
                        as * const _ as usize } , 4usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        MSLResourceBinding ) , "::" , stringify ! ( desc_set )
                        ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const MSLResourceBinding ) ) . binding
                        as * const _ as usize } , 8usize , concat ! (
                        "Alignment of field: " , stringify ! (
                        MSLResourceBinding ) , "::" , stringify ! ( binding )
                        ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const MSLResourceBinding ) ) .
                        msl_buffer as * const _ as usize } , 12usize , concat
                        ! (
                        "Alignment of field: " , stringify ! (
                        MSLResourceBinding ) , "::" , stringify ! ( msl_buffer
                        ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const MSLResourceBinding ) ) .
                        msl_texture as * const _ as usize } , 16usize , concat
                        ! (
                        "Alignment of field: " , stringify ! (
                        MSLResourceBinding ) , "::" , stringify ! (
                        msl_texture ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const MSLResourceBinding ) ) .
                        msl_sampler as * const _ as usize } , 20usize , concat
                        ! (
                        "Alignment of field: " , stringify ! (
                        MSLResourceBinding ) , "::" , stringify ! (
                        msl_sampler ) ));
            assert_eq! (unsafe {
                        & ( * ( 0 as * const MSLResourceBinding ) ) .
                        used_by_shader as * const _ as usize } , 24usize ,
                        concat ! (
                        "Alignment of field: " , stringify ! (
                        MSLResourceBinding ) , "::" , stringify ! (
                        used_by_shader ) ));
        }
        impl Clone for MSLResourceBinding {
            fn clone(&self) -> Self { *self }
        }
    }
    pub type ScInternalCompilerBase = ::std::os::raw::c_void;
    pub type ScInternalCompilerHlsl = ::std::os::raw::c_void;
    pub type ScInternalCompilerMsl = ::std::os::raw::c_void;
    pub type ScInternalCompilerGlsl = ::std::os::raw::c_void;
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum ScInternalResult {
        Success = 0,
        Unhandled = 1,
        CompilationError = 2,
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct ScEntryPoint {
        pub name: *mut ::std::os::raw::c_char,
        pub execution_model: root::spv::ExecutionModel,
        pub work_group_size_x: u32,
        pub work_group_size_y: u32,
        pub work_group_size_z: u32,
    }
    #[test]
    fn bindgen_test_layout_ScEntryPoint() {
        assert_eq!(::std::mem::size_of::<ScEntryPoint>() , 24usize , concat !
                   ( "Size of: " , stringify ! ( ScEntryPoint ) ));
        assert_eq! (::std::mem::align_of::<ScEntryPoint>() , 8usize , concat !
                    ( "Alignment of " , stringify ! ( ScEntryPoint ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const ScEntryPoint ) ) . name as * const _
                    as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( ScEntryPoint ) ,
                    "::" , stringify ! ( name ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const ScEntryPoint ) ) . execution_model as
                    * const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( ScEntryPoint ) ,
                    "::" , stringify ! ( execution_model ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const ScEntryPoint ) ) . work_group_size_x
                    as * const _ as usize } , 12usize , concat ! (
                    "Alignment of field: " , stringify ! ( ScEntryPoint ) ,
                    "::" , stringify ! ( work_group_size_x ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const ScEntryPoint ) ) . work_group_size_y
                    as * const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( ScEntryPoint ) ,
                    "::" , stringify ! ( work_group_size_y ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const ScEntryPoint ) ) . work_group_size_z
                    as * const _ as usize } , 20usize , concat ! (
                    "Alignment of field: " , stringify ! ( ScEntryPoint ) ,
                    "::" , stringify ! ( work_group_size_z ) ));
    }
    impl Clone for ScEntryPoint {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct ScHlslRootConstant {
        pub start: u32,
        pub end: u32,
        pub binding: u32,
        pub space: u32,
    }
    #[test]
    fn bindgen_test_layout_ScHlslRootConstant() {
        assert_eq!(::std::mem::size_of::<ScHlslRootConstant>() , 16usize ,
                   concat ! ( "Size of: " , stringify ! ( ScHlslRootConstant )
                   ));
        assert_eq! (::std::mem::align_of::<ScHlslRootConstant>() , 4usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( ScHlslRootConstant ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const ScHlslRootConstant ) ) . start as *
                    const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( ScHlslRootConstant
                    ) , "::" , stringify ! ( start ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const ScHlslRootConstant ) ) . end as *
                    const _ as usize } , 4usize , concat ! (
                    "Alignment of field: " , stringify ! ( ScHlslRootConstant
                    ) , "::" , stringify ! ( end ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const ScHlslRootConstant ) ) . binding as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( ScHlslRootConstant
                    ) , "::" , stringify ! ( binding ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const ScHlslRootConstant ) ) . space as *
                    const _ as usize } , 12usize , concat ! (
                    "Alignment of field: " , stringify ! ( ScHlslRootConstant
                    ) , "::" , stringify ! ( space ) ));
    }
    impl Clone for ScHlslRootConstant {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct ScHlslCompilerOptions {
        pub shader_model: i32,
        pub vertex_transform_clip_space: bool,
        pub vertex_invert_y: bool,
    }
    #[test]
    fn bindgen_test_layout_ScHlslCompilerOptions() {
        assert_eq!(::std::mem::size_of::<ScHlslCompilerOptions>() , 8usize ,
                   concat ! (
                   "Size of: " , stringify ! ( ScHlslCompilerOptions ) ));
        assert_eq! (::std::mem::align_of::<ScHlslCompilerOptions>() , 4usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( ScHlslCompilerOptions )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const ScHlslCompilerOptions ) ) .
                    shader_model as * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    ScHlslCompilerOptions ) , "::" , stringify ! (
                    shader_model ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const ScHlslCompilerOptions ) ) .
                    vertex_transform_clip_space as * const _ as usize } ,
                    4usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    ScHlslCompilerOptions ) , "::" , stringify ! (
                    vertex_transform_clip_space ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const ScHlslCompilerOptions ) ) .
                    vertex_invert_y as * const _ as usize } , 5usize , concat
                    ! (
                    "Alignment of field: " , stringify ! (
                    ScHlslCompilerOptions ) , "::" , stringify ! (
                    vertex_invert_y ) ));
    }
    impl Clone for ScHlslCompilerOptions {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct ScMslCompilerOptions {
        pub vertex_transform_clip_space: bool,
        pub vertex_invert_y: bool,
    }
    #[test]
    fn bindgen_test_layout_ScMslCompilerOptions() {
        assert_eq!(::std::mem::size_of::<ScMslCompilerOptions>() , 2usize ,
                   concat ! (
                   "Size of: " , stringify ! ( ScMslCompilerOptions ) ));
        assert_eq! (::std::mem::align_of::<ScMslCompilerOptions>() , 1usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( ScMslCompilerOptions ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const ScMslCompilerOptions ) ) .
                    vertex_transform_clip_space as * const _ as usize } ,
                    0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    ScMslCompilerOptions ) , "::" , stringify ! (
                    vertex_transform_clip_space ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const ScMslCompilerOptions ) ) .
                    vertex_invert_y as * const _ as usize } , 1usize , concat
                    ! (
                    "Alignment of field: " , stringify ! (
                    ScMslCompilerOptions ) , "::" , stringify ! (
                    vertex_invert_y ) ));
    }
    impl Clone for ScMslCompilerOptions {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct ScGlslCompilerOptions {
        pub vertex_transform_clip_space: bool,
        pub vertex_invert_y: bool,
        pub version: u32,
        pub es: bool,
    }
    #[test]
    fn bindgen_test_layout_ScGlslCompilerOptions() {
        assert_eq!(::std::mem::size_of::<ScGlslCompilerOptions>() , 12usize ,
                   concat ! (
                   "Size of: " , stringify ! ( ScGlslCompilerOptions ) ));
        assert_eq! (::std::mem::align_of::<ScGlslCompilerOptions>() , 4usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( ScGlslCompilerOptions )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const ScGlslCompilerOptions ) ) .
                    vertex_transform_clip_space as * const _ as usize } ,
                    0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    ScGlslCompilerOptions ) , "::" , stringify ! (
                    vertex_transform_clip_space ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const ScGlslCompilerOptions ) ) .
                    vertex_invert_y as * const _ as usize } , 1usize , concat
                    ! (
                    "Alignment of field: " , stringify ! (
                    ScGlslCompilerOptions ) , "::" , stringify ! (
                    vertex_invert_y ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const ScGlslCompilerOptions ) ) . version
                    as * const _ as usize } , 4usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    ScGlslCompilerOptions ) , "::" , stringify ! ( version )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const ScGlslCompilerOptions ) ) . es as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    ScGlslCompilerOptions ) , "::" , stringify ! ( es ) ));
    }
    impl Clone for ScGlslCompilerOptions {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct ScResource {
        pub id: u32,
        pub type_id: u32,
        pub base_type_id: u32,
        pub name: *mut ::std::os::raw::c_char,
    }
    #[test]
    fn bindgen_test_layout_ScResource() {
        assert_eq!(::std::mem::size_of::<ScResource>() , 24usize , concat ! (
                   "Size of: " , stringify ! ( ScResource ) ));
        assert_eq! (::std::mem::align_of::<ScResource>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( ScResource ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const ScResource ) ) . id as * const _ as
                    usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( ScResource ) , "::"
                    , stringify ! ( id ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const ScResource ) ) . type_id as * const _
                    as usize } , 4usize , concat ! (
                    "Alignment of field: " , stringify ! ( ScResource ) , "::"
                    , stringify ! ( type_id ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const ScResource ) ) . base_type_id as *
                    const _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( ScResource ) , "::"
                    , stringify ! ( base_type_id ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const ScResource ) ) . name as * const _ as
                    usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( ScResource ) , "::"
                    , stringify ! ( name ) ));
    }
    impl Clone for ScResource {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct ScResourceArray {
        pub data: *mut root::ScResource,
        pub num: usize,
    }
    #[test]
    fn bindgen_test_layout_ScResourceArray() {
        assert_eq!(::std::mem::size_of::<ScResourceArray>() , 16usize , concat
                   ! ( "Size of: " , stringify ! ( ScResourceArray ) ));
        assert_eq! (::std::mem::align_of::<ScResourceArray>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( ScResourceArray ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const ScResourceArray ) ) . data as * const
                    _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( ScResourceArray ) ,
                    "::" , stringify ! ( data ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const ScResourceArray ) ) . num as * const
                    _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( ScResourceArray ) ,
                    "::" , stringify ! ( num ) ));
    }
    impl Clone for ScResourceArray {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct ScShaderResources {
        pub uniform_buffers: root::ScResourceArray,
        pub storage_buffers: root::ScResourceArray,
        pub stage_inputs: root::ScResourceArray,
        pub stage_outputs: root::ScResourceArray,
        pub subpass_inputs: root::ScResourceArray,
        pub storage_images: root::ScResourceArray,
        pub sampled_images: root::ScResourceArray,
        pub atomic_counters: root::ScResourceArray,
        pub push_constant_buffers: root::ScResourceArray,
        pub separate_images: root::ScResourceArray,
        pub separate_samplers: root::ScResourceArray,
    }
    #[test]
    fn bindgen_test_layout_ScShaderResources() {
        assert_eq!(::std::mem::size_of::<ScShaderResources>() , 176usize ,
                   concat ! ( "Size of: " , stringify ! ( ScShaderResources )
                   ));
        assert_eq! (::std::mem::align_of::<ScShaderResources>() , 8usize ,
                    concat ! (
                    "Alignment of " , stringify ! ( ScShaderResources ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const ScShaderResources ) ) .
                    uniform_buffers as * const _ as usize } , 0usize , concat
                    ! (
                    "Alignment of field: " , stringify ! ( ScShaderResources )
                    , "::" , stringify ! ( uniform_buffers ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const ScShaderResources ) ) .
                    storage_buffers as * const _ as usize } , 16usize , concat
                    ! (
                    "Alignment of field: " , stringify ! ( ScShaderResources )
                    , "::" , stringify ! ( storage_buffers ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const ScShaderResources ) ) . stage_inputs
                    as * const _ as usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! ( ScShaderResources )
                    , "::" , stringify ! ( stage_inputs ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const ScShaderResources ) ) . stage_outputs
                    as * const _ as usize } , 48usize , concat ! (
                    "Alignment of field: " , stringify ! ( ScShaderResources )
                    , "::" , stringify ! ( stage_outputs ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const ScShaderResources ) ) .
                    subpass_inputs as * const _ as usize } , 64usize , concat
                    ! (
                    "Alignment of field: " , stringify ! ( ScShaderResources )
                    , "::" , stringify ! ( subpass_inputs ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const ScShaderResources ) ) .
                    storage_images as * const _ as usize } , 80usize , concat
                    ! (
                    "Alignment of field: " , stringify ! ( ScShaderResources )
                    , "::" , stringify ! ( storage_images ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const ScShaderResources ) ) .
                    sampled_images as * const _ as usize } , 96usize , concat
                    ! (
                    "Alignment of field: " , stringify ! ( ScShaderResources )
                    , "::" , stringify ! ( sampled_images ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const ScShaderResources ) ) .
                    atomic_counters as * const _ as usize } , 112usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( ScShaderResources )
                    , "::" , stringify ! ( atomic_counters ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const ScShaderResources ) ) .
                    push_constant_buffers as * const _ as usize } , 128usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( ScShaderResources )
                    , "::" , stringify ! ( push_constant_buffers ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const ScShaderResources ) ) .
                    separate_images as * const _ as usize } , 144usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( ScShaderResources )
                    , "::" , stringify ! ( separate_images ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const ScShaderResources ) ) .
                    separate_samplers as * const _ as usize } , 160usize ,
                    concat ! (
                    "Alignment of field: " , stringify ! ( ScShaderResources )
                    , "::" , stringify ! ( separate_samplers ) ));
    }
    impl Clone for ScShaderResources {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct ScSpecializationConstant {
        pub id: u32,
        pub constant_id: u32,
    }
    #[test]
    fn bindgen_test_layout_ScSpecializationConstant() {
        assert_eq!(::std::mem::size_of::<ScSpecializationConstant>() , 8usize
                   , concat ! (
                   "Size of: " , stringify ! ( ScSpecializationConstant ) ));
        assert_eq! (::std::mem::align_of::<ScSpecializationConstant>() ,
                    4usize , concat ! (
                    "Alignment of " , stringify ! ( ScSpecializationConstant )
                    ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const ScSpecializationConstant ) ) . id as
                    * const _ as usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    ScSpecializationConstant ) , "::" , stringify ! ( id ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const ScSpecializationConstant ) ) .
                    constant_id as * const _ as usize } , 4usize , concat ! (
                    "Alignment of field: " , stringify ! (
                    ScSpecializationConstant ) , "::" , stringify ! (
                    constant_id ) ));
    }
    impl Clone for ScSpecializationConstant {
        fn clone(&self) -> Self { *self }
    }
    #[repr(C)]
    #[derive(Debug, Copy)]
    pub struct ScType {
        pub type_: root::spirv_cross::SPIRType_BaseType,
        pub member_types: *mut u32,
        pub member_types_size: usize,
        pub array: *mut u32,
        pub array_size: usize,
    }
    #[test]
    fn bindgen_test_layout_ScType() {
        assert_eq!(::std::mem::size_of::<ScType>() , 40usize , concat ! (
                   "Size of: " , stringify ! ( ScType ) ));
        assert_eq! (::std::mem::align_of::<ScType>() , 8usize , concat ! (
                    "Alignment of " , stringify ! ( ScType ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const ScType ) ) . type_ as * const _ as
                    usize } , 0usize , concat ! (
                    "Alignment of field: " , stringify ! ( ScType ) , "::" ,
                    stringify ! ( type_ ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const ScType ) ) . member_types as * const
                    _ as usize } , 8usize , concat ! (
                    "Alignment of field: " , stringify ! ( ScType ) , "::" ,
                    stringify ! ( member_types ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const ScType ) ) . member_types_size as *
                    const _ as usize } , 16usize , concat ! (
                    "Alignment of field: " , stringify ! ( ScType ) , "::" ,
                    stringify ! ( member_types_size ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const ScType ) ) . array as * const _ as
                    usize } , 24usize , concat ! (
                    "Alignment of field: " , stringify ! ( ScType ) , "::" ,
                    stringify ! ( array ) ));
        assert_eq! (unsafe {
                    & ( * ( 0 as * const ScType ) ) . array_size as * const _
                    as usize } , 32usize , concat ! (
                    "Alignment of field: " , stringify ! ( ScType ) , "::" ,
                    stringify ! ( array_size ) ));
    }
    impl Clone for ScType {
        fn clone(&self) -> Self { *self }
    }
    extern "C" {
        pub fn sc_internal_get_latest_exception_message(message:
                                                            *mut *const ::std::os::raw::c_char)
         -> root::ScInternalResult;
    }
    extern "C" {
        pub fn sc_internal_compiler_hlsl_new(compiler:
                                                 *mut *mut root::ScInternalCompilerHlsl,
                                             ir: *const u32, size: usize)
         -> root::ScInternalResult;
    }
    extern "C" {
        pub fn sc_internal_compiler_hlsl_set_options(compiler:
                                                         *const root::ScInternalCompilerHlsl,
                                                     options:
                                                         *const root::ScHlslCompilerOptions)
         -> root::ScInternalResult;
    }
    extern "C" {
        pub fn sc_internal_compiler_hlsl_set_root_constant_layout(compiler:
                                                                      *const root::ScInternalCompilerHlsl,
                                                                  constants:
                                                                      *const root::ScHlslRootConstant,
                                                                  count:
                                                                      usize)
         -> root::ScInternalResult;
    }
    extern "C" {
        pub fn sc_internal_compiler_msl_new(compiler:
                                                *mut *mut root::ScInternalCompilerMsl,
                                            ir: *const u32, size: usize)
         -> root::ScInternalResult;
    }
    extern "C" {
        pub fn sc_internal_compiler_msl_set_options(compiler:
                                                        *const root::ScInternalCompilerMsl,
                                                    options:
                                                        *const root::ScMslCompilerOptions)
         -> root::ScInternalResult;
    }
    extern "C" {
        pub fn sc_internal_compiler_msl_compile(compiler:
                                                    *const root::ScInternalCompilerBase,
                                                shader:
                                                    *mut *const ::std::os::raw::c_char,
                                                p_vat_overrides:
                                                    *const root::spirv_cross::MSLVertexAttr,
                                                vat_override_count: usize,
                                                p_res_overrides:
                                                    *const root::spirv_cross::MSLResourceBinding,
                                                res_override_count: usize)
         -> root::ScInternalResult;
    }
    extern "C" {
        pub fn sc_internal_compiler_glsl_new(compiler:
                                                 *mut *mut root::ScInternalCompilerGlsl,
                                             ir: *const u32, size: usize)
         -> root::ScInternalResult;
    }
    extern "C" {
        pub fn sc_internal_compiler_glsl_set_options(compiler:
                                                         *const root::ScInternalCompilerGlsl,
                                                     options:
                                                         *const root::ScGlslCompilerOptions)
         -> root::ScInternalResult;
    }
    extern "C" {
        pub fn sc_internal_compiler_glsl_build_combined_image_samplers(compiler:
                                                                           *const root::ScInternalCompilerBase)
         -> root::ScInternalResult;
    }
    extern "C" {
        pub fn sc_internal_compiler_get_decoration(compiler:
                                                       *const root::ScInternalCompilerBase,
                                                   result: *mut u32, id: u32,
                                                   decoration:
                                                       root::spv::Decoration)
         -> root::ScInternalResult;
    }
    extern "C" {
        pub fn sc_internal_compiler_set_decoration(compiler:
                                                       *const root::ScInternalCompilerBase,
                                                   id: u32,
                                                   decoration:
                                                       root::spv::Decoration,
                                                   argument: u32)
         -> root::ScInternalResult;
    }
    extern "C" {
        pub fn sc_internal_compiler_get_entry_points(compiler:
                                                         *const root::ScInternalCompilerBase,
                                                     entry_points:
                                                         *mut *mut root::ScEntryPoint,
                                                     size: *mut usize)
         -> root::ScInternalResult;
    }
    extern "C" {
        pub fn sc_internal_compiler_get_cleansed_entry_point_name(compiler:
                                                                      *const root::ScInternalCompilerBase,
                                                                  original_entry_point_name:
                                                                      *const ::std::os::raw::c_char,
                                                                  execution_model:
                                                                      root::spv::ExecutionModel,
                                                                  compiled_entry_point_name:
                                                                      *mut *const ::std::os::raw::c_char)
         -> root::ScInternalResult;
    }
    extern "C" {
        pub fn sc_internal_compiler_get_shader_resources(compiler:
                                                             *const root::ScInternalCompilerBase,
                                                         shader_resources:
                                                             *mut root::ScShaderResources)
         -> root::ScInternalResult;
    }
    extern "C" {
        pub fn sc_internal_compiler_get_specialization_constants(compiler:
                                                                     *const root::ScInternalCompilerBase,
                                                                 constants:
                                                                     *mut *mut root::ScSpecializationConstant,
                                                                 size:
                                                                     *mut usize)
         -> root::ScInternalResult;
    }
    extern "C" {
        pub fn sc_internal_compiler_set_scalar_constant(compiler:
                                                            *const root::ScInternalCompilerBase,
                                                        id: u32,
                                                        constant: u64)
         -> root::ScInternalResult;
    }
    extern "C" {
        pub fn sc_internal_compiler_get_type(compiler:
                                                 *const root::ScInternalCompilerBase,
                                             id: u32,
                                             spirv_type:
                                                 *mut *const root::ScType)
         -> root::ScInternalResult;
    }
    extern "C" {
        pub fn sc_internal_compiler_get_member_name(compiler:
                                                        *const root::ScInternalCompilerBase,
                                                    id: u32, index: u32,
                                                    name:
                                                        *mut *const ::std::os::raw::c_char)
         -> root::ScInternalResult;
    }
    extern "C" {
        pub fn sc_internal_compiler_get_member_decoration(compiler:
                                                              *const root::ScInternalCompilerBase,
                                                          id: u32, index: u32,
                                                          decoration:
                                                              root::spv::Decoration,
                                                          result: *mut u32)
         -> root::ScInternalResult;
    }
    extern "C" {
        pub fn sc_internal_compiler_set_member_decoration(compiler:
                                                              *const root::ScInternalCompilerBase,
                                                          id: u32, index: u32,
                                                          decoration:
                                                              root::spv::Decoration,
                                                          argument: u32)
         -> root::ScInternalResult;
    }
    extern "C" {
        pub fn sc_internal_compiler_get_declared_struct_size(compiler:
                                                                 *const root::ScInternalCompilerBase,
                                                             id: u32,
                                                             result: *mut u32)
         -> root::ScInternalResult;
    }
    extern "C" {
        pub fn sc_internal_compiler_get_declared_struct_member_size(compiler:
                                                                        *const root::ScInternalCompilerBase,
                                                                    id: u32,
                                                                    index:
                                                                        u32,
                                                                    result:
                                                                        *mut u32)
         -> root::ScInternalResult;
    }
    extern "C" {
        pub fn sc_internal_compiler_compile(compiler:
                                                *const root::ScInternalCompilerBase,
                                            shader:
                                                *mut *const ::std::os::raw::c_char)
         -> root::ScInternalResult;
    }
    extern "C" {
        pub fn sc_internal_compiler_delete(compiler:
                                               *mut root::ScInternalCompilerBase)
         -> root::ScInternalResult;
    }
    extern "C" {
        pub fn sc_internal_free_pointer(pointer: *mut ::std::os::raw::c_void)
         -> root::ScInternalResult;
    }
}
